#include <string.h>
#include <rfsmUtils.h>
#include <rfsm.h>

using namespace rfsm;

LuaTraceCallback* Utils::traceCallback = NULL;

int Utils::report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    std::string strMessage = (msg != NULL) ? msg : "(error object is not a string)";
    lua_pop(L, 1);
    if(traceCallback)
        traceCallback->onTrace(strMessage);
    else
        yError()<<strMessage.c_str()<<ENDL;
  }
  return status;
}

int Utils::traceback (lua_State *L) {
#if LUA_VERSION_NUM > 501
  const char *msg = lua_tostring(L, 1);
  if (msg)
    luaL_traceback(L, L, msg, 1);
  else if (!lua_isnoneornil(L, 1)) {  /* is there an error object? */
    if (!luaL_callmeta(L, 1, "__tostring"))  /* try its 'tostring' metamethod */
      lua_pushliteral(L, "(no error message)");
  }
  return 1;
#else
    lua_getfield(L, LUA_GLOBALSINDEX, "debug");
    if (!lua_istable(L, -1)) {
      lua_pop(L, 1);
      return 1;
    }
    lua_getfield(L, -1, "traceback");
    if (!lua_isfunction(L, -1)) {
      lua_pop(L, 2);
      return 1;
    }
    lua_pushvalue(L, 1);  /* pass error message */
    lua_pushinteger(L, 2);  /* skip this function and traceback */
    lua_call(L, 2, 1);  /* call debug.traceback */
    return 1;
#endif
}

int Utils::docall(lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}


int Utils::dofile(lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || docall(L, 0, 1);
  return report(L, status);
}


int Utils::dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || docall(L, 0, 1);
  return report(L, status);
}


int Utils::dolibrary (lua_State *L, const char *name) {
  lua_getglobal(L, "require");
  lua_pushstring(L, name);
  return report(L, lua_pcall(L, 1, 0, 0));
}

bool Utils::isNilTableField(lua_State *L, const char *key) {
    lua_pushstring(L, key);
    lua_gettable(L, -2);
    bool result = lua_isnil(L, -1);
    lua_pop(L, 1);
    return result;
}


std::string Utils::getTableStringField(lua_State *L, const char *key) {
    std::string result;
    lua_pushstring(L, key);
    lua_gettable(L, -2);
    if (!lua_isstring(L, -1)) {
        lua_pop(L, 1);
        return "";
    }
    result =  lua_tostring(L, -1);
    lua_pop(L, 1);
    return result;
}

void Utils::setLuaTraceCallback(LuaTraceCallback* callback) {
     Utils::traceCallback = callback;
}
